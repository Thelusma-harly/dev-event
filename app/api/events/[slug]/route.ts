import { Event, type IEvent } from "@/database";
import { connectToDatabase } from "@/lib/mongodb";
import { type NextRequest, NextResponse } from "next/server";

type RouteContext = {
  // Next's route handler type generation for dynamic segments expects `params` to be a Promise.
  params: Promise<{
    slug: string;
  }>;
};

type LeanEvent = IEvent & {
  slug: string;
};

function jsonError(message: string, status: number): NextResponse {
  return NextResponse.json({ message }, { status });
}

function isValidSlug(value: string): boolean {
  // Slugs are generated by the Event model (lowercase, hyphen-separated).
  // Keep this strict to avoid unexpected query patterns.
  return /^[a-z0-9]+(?:-[a-z0-9]+)*$/.test(value);
}

export async function GET(_req: NextRequest, { params }: RouteContext) {
  const { slug: rawSlug } = await params;

  if (!rawSlug) {
    return jsonError("Missing required route parameter: slug", 400);
  }

  let slug: string;
  try {
    // Guard against malformed percent-encoding.
    slug = decodeURIComponent(rawSlug).trim();
  } catch {
    return jsonError("Invalid slug encoding", 400);
  }

  if (!isValidSlug(slug)) {
    return jsonError(
      "Invalid slug format. Use lowercase letters, numbers, and hyphens only.",
      400,
    );
  }

  try {
    await connectToDatabase();

    const event = await Event.findOne({ slug })
      .select("-__v")
      .lean<LeanEvent | null>();

    if (!event) {
      return jsonError("Event not found", 404);
    }

    return NextResponse.json(
      { message: "Successfully fetched event", event },
      { status: 200 },
    );
  } catch (error: unknown) {
    // In production you might also log to a centralized logger.
    const message = error instanceof Error ? error.message : "Unknown error";
    return NextResponse.json(
      { message: "Failed to fetch event", error: message },
      { status: 500 },
    );
  }
}
