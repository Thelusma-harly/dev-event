import { Event, type IEvent } from "@/database";
import { connectToDatabase } from "@/lib/mongodb";
import { Types } from "mongoose";
import { type NextRequest, NextResponse } from "next/server";

type RouteContext = {
  // Next's route handler type generation for dynamic segments expects `params` to be a Promise.
  params: Promise<{
    slug: string;
  }>;
};

type LeanEvent = Omit<IEvent, "createdAt" | "updatedAt"> & {
  _id: Types.ObjectId;
  slug: string;
  createdAt: Date;
  updatedAt: Date;
};

type EventJson = Omit<IEvent, "createdAt" | "updatedAt"> & {
  _id: string;
  slug: string;
  createdAt: string;
  updatedAt: string;
};

function jsonError(message: string, status: number): NextResponse {
  return NextResponse.json({ message }, { status });
}

function isValidSlug(value: string): boolean {
  // Slugs are generated by the Event model (lowercase, hyphen-separated).
  // Keep this strict to avoid unexpected query patterns.
  return /^[a-z0-9]+(?:-[a-z0-9]+)*$/.test(value);
}

function serializeEvent(event: LeanEvent): EventJson {
  const { _id, createdAt, updatedAt, ...rest } = event;
  return {
    ...rest,
    _id: _id.toString(),
    createdAt: createdAt.toISOString(),
    updatedAt: updatedAt.toISOString(),
  };
}

export async function GET(_req: NextRequest, { params }: RouteContext) {
  const { slug: rawSlug } = await params;

  if (!rawSlug) {
    return jsonError("Missing required route parameter: slug", 400);
  }

  let slug: string;
  try {
    // Guard against malformed percent-encoding.
    slug = decodeURIComponent(rawSlug).trim();
  } catch {
    return jsonError("Invalid slug encoding", 400);
  }

  if (!isValidSlug(slug)) {
    return jsonError(
      "Invalid slug format. Use lowercase letters, numbers, and hyphens only.",
      400,
    );
  }

  try {
    await connectToDatabase();

    const event = await Event.findOne({ slug })
      .select("-__v")
      .lean<LeanEvent | null>();

    if (!event) {
      return jsonError("Event not found", 404);
    }

    return NextResponse.json(
      { message: "Successfully fetched event", event: serializeEvent(event) },
      { status: 200 },
    );
  } catch (error: unknown) {
    // In production you might also log to a centralized logger.
    const message = error instanceof Error ? error.message : "Unknown error";
    return NextResponse.json(
      { message: "Failed to fetch event", error: message },
      { status: 500 },
    );
  }
}
