import { Event, type IEvent } from "@/database";
import { connectToDatabase } from "@/lib/mongodb";
import { Types } from "mongoose";
import { type NextRequest, NextResponse } from "next/server";

type RouteContext = {
  // Next's route handler type generation for dynamic segments expects `params` to be a Promise.
  params: Promise<{
    slug: string;
  }>;
};

type LeanEvent = Omit<IEvent, "createdAt" | "updatedAt"> & {
  _id: Types.ObjectId;
  slug: string;
  createdAt: Date;
  updatedAt: Date;
};

type EventJson = Omit<IEvent, "createdAt" | "updatedAt"> & {
  _id: string;
  slug: string;
  createdAt: string;
  updatedAt: string;
};

/**
 * Create a JSON HTTP response containing an error message and the specified status code.
 *
 * @param message - The error message to include in the response body
 * @param status - The HTTP status code for the response
 * @returns A response with a JSON body `{ message }` and the given HTTP status code
 */
function jsonError(message: string, status: number): NextResponse {
  return NextResponse.json({ message }, { status });
}

/**
 * Validate that a string is a canonical slug composed of lowercase alphanumeric segments separated by single hyphens.
 *
 * @param value - The candidate slug string to validate
 * @returns `true` if `value` consists of one or more lowercase letters or digits optionally separated by single hyphens (no leading, trailing, or consecutive hyphens), `false` otherwise
 */
function isValidSlug(value: string): boolean {
  // Slugs are generated by the Event model (lowercase, hyphen-separated).
  // Keep this strict to avoid unexpected query patterns.
  return /^[a-z0-9]+(?:-[a-z0-9]+)*$/.test(value);
}

/**
 * Produce an EventJson by converting the event's `_id` and timestamp fields to strings.
 *
 * @param event - A LeanEvent whose `_id` is an ObjectId and whose `createdAt` and `updatedAt` are Date objects
 * @returns An EventJson with `_id`, `createdAt`, and `updatedAt` serialized to strings
 */
function serializeEvent(event: LeanEvent): EventJson {
  const { _id, createdAt, updatedAt, ...rest } = event;
  return {
    ...rest,
    _id: _id.toString(),
    createdAt: createdAt.toISOString(),
    updatedAt: updatedAt.toISOString(),
  };
}

/**
 * Handle GET requests for a single event identified by slug; validates the slug, fetches the event from the database, and returns a JSON response.
 *
 * @param _req - The incoming NextRequest (unused)
 * @param params - Route context containing a promise resolving to an object with the `slug` route parameter
 * @returns On success: an object with `message: "Successfully fetched event"` and `event` (serialized event data). On client errors: an object with `message` describing the problem (status 400 or 404). On unexpected server errors: an object with `message: "Failed to fetch event"` and `error` describing the failure (status 500).
 */
export async function GET(_req: NextRequest, { params }: RouteContext) {
  const { slug: rawSlug } = await params;

  if (!rawSlug) {
    return jsonError("Missing required route parameter: slug", 400);
  }

  let slug: string;
  try {
    // Guard against malformed percent-encoding.
    slug = decodeURIComponent(rawSlug).trim();
  } catch {
    return jsonError("Invalid slug encoding", 400);
  }

  if (!isValidSlug(slug)) {
    return jsonError(
      "Invalid slug format. Use lowercase letters, numbers, and hyphens only.",
      400,
    );
  }

  try {
    await connectToDatabase();

    const event = await Event.findOne({ slug })
      .select("-__v")
      .lean<LeanEvent | null>();

    if (!event) {
      return jsonError("Event not found", 404);
    }

    return NextResponse.json(
      { message: "Successfully fetched event", event: serializeEvent(event) },
      { status: 200 },
    );
  } catch (error: unknown) {
    // In production you might also log to a centralized logger.
    const message = error instanceof Error ? error.message : "Unknown error";
    return NextResponse.json(
      { message: "Failed to fetch event", error: message },
      { status: 500 },
    );
  }
}